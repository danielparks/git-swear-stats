#!/usr/bin/env ruby
# encoding: utf-8

# May you recognize your weaknesses and share your strengths.
# May you share freely, never taking more than you give.
# May you find love and love everyone you find.

require 'git'
require 'pp'

swears = [
   %r{^(dip)?shit(ty)?$},
   %r{^(mother)?(fuck|fsck|eff)(ing|er|ed|head)?$},
   %r{^cunt$},
   %r{^cock(suck|sucker)?$},
   %r{^(ass|arse)(hole)?$},
   %r{^bitch(y)?$},
   %r{^wtf$},
   %r{^fag(got)?$},
   %r{^(god)?damn(ed|able)?$},
   %r{^bastard$},
   %r{^hell(ish)?$},
]

wordStats = {}
wordStats.default = 0
authorStats = {}

repo = Git.open '.'
# By default, we only get up to 30 commits in the log.  By digging through the
# source, I found that passing nil to repo.log() ends up setting the limit to
# nil, and thus giving us all commits.
print 'Reading in git log... '
log = repo.log nil
puts 'done!'

print 'Parsing commit messages'
log.each_with_index do |commit, i|
   author = commit.author.name
   if not authorStats.key? author
      authorStats[author] = {}
      authorStats[author].default = 0
   end
   
   # Splitting on words makes our regexes a little simpler.
   commit.message.split(%r{[ \-_.,!?;:*"'\n]}).each do |word|
      word.downcase! # A little bit of normalization.
      swears.each do |swear|
         if word =~ swear
            wordStats[word] += 1
            authorStats[author][word] += 1
         end
      end
   end
   # For large repos, parsing can take a while; let users know something is
   # happening.
   print '.' if i % 100 == 0
end

# People who haven't sworn at all aren't very interesting.
authorStats.delete_if {|author, swears| swears.empty?}

puts
pp wordStats
pp authorStats

